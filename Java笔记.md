# **Java**

位（bit） 一个数字0或一个数字1，代表一位

字节（Byte） 每逢8位是一个字节，这是数据存储的最小单位

**JRE**(Java Runtime Environment)：是Java程序的运行环境，包含JVM和运行所需要的核心库

**JDK**(Java Development Kit)：是Java程序开发工具包，包含JRE和开发人员使用的工具

我们想要运行一个已有的Java程序，那么只需要安装JRE即可

我们想要开发一个全新的Java程序，那么必须安装JDK

![img](.\image\1c4f04f0b2384948a2ddd33079e58e1a.jpg)

## **关键字的概念与特征**

1、完全小写的字母 public

2、编辑中有特殊的颜色

### **标识符**

是指在程序中我们自己定义内容，比如类的名字、方法的名字和变量的名字等等

命名规则

​	可以包含大小写字母、数字、$、_下划线

​	不能数字开头

​	不能是关键字

命名规范

​	类名驼峰法开头首字母大写

​	变量小驼峰法开头首字母小写

不能数字开头

不能是关键字

命名规范

类名驼峰法开头首字母大写

变量小驼峰法开头首字母小写

### **基本数据类型**

Java的数据类型分为两大类：

基本数据类型：

#### **整型**：

​	byte：字节型 	1个字节 	 -128~127

​	short：短整型    2个字节 	-32768~32767

​	默认int：整型 	4个字节 	-2的31次方~2的31次方减1

​	long： 长整型 	8个字节     -2的63次方~2的63次方减1  定义时加**L**或**l**

#### **浮点型**：

​	float：单精度浮点型   4个字节  定义时加**f**或**F**

​	默认double：双精度浮点型  8个字节

#### **字符**：

​	char：字符型   2个字节   0~65535	Unicode编码

#### **布尔**：

​	Boolean：布尔型   1个字节  true  false

​	引用数据类型：**字符串**、**类**、**数组**、**接口**、**Lambda**

#### 数据类型转换

自动类型转换（隐式）

​	特点：代码不需要进行特殊处理，自动完成

​	规则：数据范围从小到大

​	int --> long

​	float --> double

​	long --> float

强制类型转换（显式）

​	格式：范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据

```java
int num = (int) 100L;
```

##### 注意事项

​	1、强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出

​	2、byte/short/char这三种数据类型都可以发生数学运算，例如加法

​	3、byte/short/char这三种数据在运算的时候，都会被首先提升成为int类型，然后再计算

​	byte类型 + byte类型 结果是int类型

## **常量和变量**

**常量**：在程序运行期间，固定不变的量

### 常量的分类：

​	1、字符串常量：凡是双引号引起来的部分，叫做字符串常量

​	2、空常量：null 代表没有任何数据

### **变量**

​	在程序中可以变化的量称为变量  数据类型  变量名称

#### 注意事项：

​	1、变量名**不能重复**

​	2、float和long类型，定义的时候后面的F和L不能忘了 

```java
float f = 2.12F; long l = 12L; 
```

​	3、不能超出取值范围  byte  short

​	4、没有进行赋值的变量不能直接使用，一定要赋值后才能使用

​	作用域：从定义变量的一行开始，一直到所属大括号结束为止 

## **选择语句**

```java
单分支 条件成立执行大括号的内容 
if (条件) {
} 
双分支 条件成立执行大括号的内容，否则执行else里的 
if (条件) {
} else {
} 
多分支 
if (条件) {  
} else if (条件) {   
} else {  
} 
switch语句 
括号里面只能是 byte/short/char/int String enum 枚举这五种类型 
switch (表达式) {     
    case 常量1:
        语句1;
        break;
    case 常量2:
        语句2;
        break;
    case 常量3:
        语句3;
        break;
        ……
    default:
        语句
} 
```

## **循环语句**

```java
while循环  
while里面的条件成立才会执行直到条件不成立退出 
while () {
循环体
}
do……while
先执行一遍程序然后判断
do {
循环体
} while ()
while (布尔表达式) {
    
} 
for (初始表达式; 布尔表达式; 步进表达式) {
    循环体;
} 
for (int i = 0; i < 100; i++) {
    
}
Loop: for (int i = 0; i< 10; i ++) {
    System.out.println(i);
    if (i > 5) {
        break Loop; 跳出被标记的for循环
    }
}
```

## **方法**

**方法**：就是将一个功能抽取出来，把代码定义在一个大括号内，形成一个单独的功能

### 注意事项

​	1、方法定义的先后顺序无所谓  加了static修饰符的

​	2、方法定义必须是挨着的，不能在一个方法内部定义另外一个方法

​	3、定义的方法不会自己执行，如果希望执行，一定要进行方法的调用

### **参数和返回值**

参数(原料)：就是进入方法的数据  形参

返回值(产出物)return：就是方法出来的数据

方法的三种调用方式

​	1、单独调用：方法名称(参数);

​	2、打印调用：System.out.println(方法名称(参数));

​	3、赋值调用：数据类型 变量名称 = 方法名称(参数);  只适用有返回值的 数据类型要一致

### 语法

```java
修饰符 返回值类型 方法名称 (参数类型 参数名称, .....) {  形参是数据类型+变量名    
	方法体;    
    return 返回的数据; 定义了返回值类型才可以用 返回数据要与返回值类型一致
} 
public static void 方法名称 (int a) {} 
```

### 注意事项

​	1、方法应该定义在类中，但是不能在方法当中再定义方法

​	2、方法定义的前后顺序无所谓

​	3、方法定义之后不会执行，要想执行必须调用

​	4、如果方法有返回值，那么必须写上“return 返回值”，不能没有

​	5、return后面的返回值数据，必须和方法的返回值类型对应起来

​	6、void没有返回值的方法，不能写return后面的返回值，只能写return自己

​	7、一个方法可以有多个return语句，但是必须保证同时只有一个会被执行到

### **方法重载overload**

多个方法的名称一样，但是参数列表不一样

好处：只需要记住唯一一个方法名称，就可以实现类似的多个功能

**方法重载与下列因数相关：**

​	1、参数个数不同

​	2、参数类型不同

​	3、参数的多类型顺序不同

**方法重载与下列因数无关：**

​	1、与参数的名称无关

​	2、与返回值的类型无关

## **数组**

**数组**：是一种容器，可以同时存放多个数据值

### 数组的特点：

​	1、数组是一种引用数据类型

​	2、数组当中的多个数组，类型必须统一

​	3、数组的长度在程序运行期间不可改变

​	数组的初始化：在内存中创建一个数组，并且向其中赋予一些默认值

### 两种常见的初始化方式

​	1、动态初始化（指定长度）

​	2、静态初始化（指定内容）

#### 动态初始化数组的格式

```java
数据类型[] 数组名称 = new 数据类型[数组长度]; 
int[] arr = new int[10]; 
定义是没有给值的时候，会自动给一个默认值 
	整数类型，默认值是0 
    浮点类型，默认值是0.0 
    字符类型，默认值是'\u0000' unicode编码 
    布尔类型，默认值是false 
    引用类型，默认值是null 
```

#### 静态初始化数组的格式

虽然静态初始化没有直接告诉长度，但是根据大括号里面元素的具体内容，也可以自动推算出来长度

```java
标准格式 数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, 元素3, ..... }; 
int[] arr = new int[] { 1, 2, 3, 4 }; 
拆分步骤
int[] arr; 
arr = new int[] { 1, 2, 3, 4 }; 

省略格式 数据类型[] 数组名称 = { 元素1, 元素2, 元素3, ..... }; 
int[] arr = { 1, 2, 3, 4 }; 
```

#### 注意事项

​	1、静态初始化没有直接指定长度，但是仍然会自动推算得到长度

​	2、静态初始化标准格式可以拆分成两个步骤

​	3、动态初始化也可以拆分成两个步骤

​	4、静态初始化一旦使用省略格式，就不能拆分成两个步骤了

直接打印数组名称，得到的是数组对应的内存地址哈希值

```
直接打印得到的 [I@7c30a502 
[代表是数组  
I 代表int类型的 
@后面是数组的内存地址 
```

### **对象数组**

创建类的数组然后创建类可以把创建的类存储在数组中

```java
Student stu1 = new Student("dllm", 20); 
Student stu2 = new Student("张三", 30); 
Student stu3 = new Student("李四", 40); 
Student[] arr = new Student[3];
arr[0] = stu1; 
arr[1] = stu2; 
arr[2] = stu3; 
```

#### **数组作为方法传参或返回值**

数组可以作为方法的参数：

​	当调用方法的时候，向方法的小括号进行传参，传递进去的其实是数组的地址值

数组可以作为方法的返回值：返回的也是数组的地址值

## **Java内存需要划分成为5个部分**

**1、栈（Stack）**：存放的都是方法中的局部变量，

​	方法的运行一定要在栈中，并且在栈内存中开辟内存空间这个动作叫做进入栈内存（进栈）

​	局部变量：方法的参数，或是方法{}内部的变量

​	作用域：一旦超出作用域，立即从栈内存当中消失（出栈）

**2、堆（Heap）**：凡是new出来的东西，都在堆当中

​	堆内存里面的东西都有一个地址值：16进制

​	堆内存里面的数据，都有默认值

**3、方法区（Method Area）**：存储.class相关信息，包含方法的信息 

**4、本地地方栈（Native Method Stack）**：与操作系统相关

**5、寄存器（pc Register**）：与CPU相关

## **类和对象**

### 类

**类**：是一组相关属性和行为的集合。可以看成一类事物的模板，使用事物的属性和特征来描述该类事物

**属性**：就是该事物的状态信息  

**行为**：就是该事物能做什么

#### 类的定义

成员变量（属性）：

​	String name

​	int age

成员方法（行为）：

​	public void eat() {} // 吃饭

#### **类的使用**

**1、导包**

也就是指出需要的类在什么位置

```java
import 包名称.类名称
import com.tedu.Student
```

对于和当前类属于同一个包的情况下，可以省略导包语句不写

**2、创建**

类名称 对象名 = new 类名称();

根据Student类，创建了一个名为stu的对象

```java
Student stu = new Student();
```

**3、使用**

​	1、使用成员变量：对象名.成员变量

​	2、使用对象方法：对象名.成员方法名(参数)

成员方法在堆当中存储的是一个地址值，在调用对象方法的时候就会通过堆中存储的地址值找到这个方法的地址值，然后进栈执行，执行完成之后出栈（在栈中销毁）

![img](.\image\2e406849cd614948aaf9a92a924fc22d.jpg)

#### 使用对象类型作为方法的参数

传递实参的对象类型要与函数定义的形参类型一致，传递的实参的地址值

![img](.\image\aa9e716379d440c9a363e88edb2497f2.jpg)

### **局部变量和成员变量**

**1、定义的位置不一样[重点]**

​	局部变量：在方法内部

​	成员变量：在方法外部，直接写在类中

**2、作用域[重点]**

​	局部变量：只有方法中才可以使用，出了方法就不能用

​	成员变量：整个类都可以用

**3、默认值不一样[重点]**

​	局部变量：没有默认值，如果要想使用，必须手动进行赋值

​	成员变量：如果没有赋值，会有默认值，规则和数组一样

**4、内存的位置不一样**

​	局部变量：位于栈内存

​	成员变量：位于堆内存

**5、生命周期不一样**

​	局部变量：随着方法进栈而诞生，随着方法出栈而消失

​	成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失

### **this关键字的作用**

当方法的局部变量和成员变量重名的时候，根据就近原则，优先使用局部变量。

如果需要访问本类当中的成员变量，需要使用格式：this.成员变量名

谁调用的方法，谁就是this  内存地址一样

### **类的构造方法**

构造方法是专门用来创建对象的方法，当我们通过new来创建对象时，其实就是在调用构造方法

格式：

```java
public 类名称(参数类型 参数名称) {    
	方法体 
} 
```

#### 注意事项：

​	1、构造方法的名称必须和所在类名称完全一样，就连大小写也要一样

​	2、构造方法不要写返回值类型，void也不要写

​	3、构造方法不能return一个具体的返回值

​	4、如果没有写任何构造方法，编译器会自动创建一个，没有参数、方法体

​	5、一旦编写了至少一个构造方法，那么编译器就不会自动创建

​	6、构造方法也是可以进行重载的，参数列表不同

### **定义一个标准的类**

一个标准的类通常都要拥有下面四个组成部分：

​	1、所有的成员变量都要使用private关键字修饰

​	2、为每个成员变量编写一对Getter/Setter方法

​	3、编写一个无参的构造方法

​	4、编写一个全参的构造方法

​	这样的标准类也叫做Java Bean

### **匿名对象**

匿名对象就是只有右边的对象，没有左边的名字和赋值运算符

new 类名称();  

注意事项：匿名对象只能使用唯一的一次，下次再用不得不创建一个新的对象

匿名对象可以做返回值和方法参数

### 静态static关键字

一旦使用了static关键字，那么这样的内容不再属于对象自己，而是属于类的，所以返回本类的对象，都共享一份

使用static修饰的静态方法可以直接类名.静态方法名调用，成员方法和成员变量都推荐使用**类名.静态方法名**

对于本类当中调用本类的静态方法可以省略类名称.

#### 注意事项

​	1、静态不能直接访问非静态

​		静态成员方法不能直接访问静态成员变量

​		因为在内存当中是先有的静态内容，后有的非静态内容（先人不知道后人，后人知道先人）

​	2、静态方法当中不能使用this

​		原因：this代表当前对象，通过谁调用的方法，谁就是当前对象（this）

#### 静态static的内存图

![img](C:\Users\48356\Desktop\笔记\image\QQ截图20200507113224.png)

#### 静态代码块

```java
public class 类名称 {
	static {
		// 静态代码块内容
	}
}
特点：当第一次用到本类时，静态代码块执行唯一的一次
静态的内容总是优先于非静态，所以静态代码块比构造方法先执行
静态代码块的典型用途：
用来一次性的给静态成员变量进行赋值
```

### 三大特性

三大特征：封装、多态、继承

#### 封装

**封装**：就是将一些细节信息隐藏起来，对于外界不可见

​	1、方法就是一种封装

​	2、关键字private也是一种封装符

##### **private修饰符关键字**

private修饰符关键字可以用来阻止不合理的数据进入

一旦使用了private进行修饰，那么本类可以随意访问，但是超出本类范围之外就不能直接访问

间接访问private成员变量，就是定义一堆Getter/Setter方法

必须叫setXxx和getXxx命名规则

对于Getter来说，不能有参数，返回值类型和成员变量对应；

对于Setter来说，不能有返回值，参数类型和成员变量对应；

布尔类型的是setXxx和isXxx

```java
private boolean male; 
public void setMale(boolean b) {    
    male = b; 
} 
public boolean isMale() {    
    return male; 
} 
```

#### 继承

继承是多态的前提，没有继承就没有多态，继承主要解决的问题就是：共性抽取

父类：也可以叫基类，超类

子类：也可以叫派生类

##### 继承关系当中的特点：

​	1、子类可以拥有父类的“内容”

​	2、子类还可以拥有自己专有的内容

在继承关系中，“子类就是一个父类”，也就是说，子类可以被当做父类看待

定义父类的格式：（一个普通的类）

​	public class 类名 {}

定义子类的格式：

​	public class 子类名称 extends 父类名称 {}

在子类继承关系中，如果成员变量重名，则创建子类对象时，访问有两种方式

​	1、直接通过子类对象访问成员变量

​		等号左边是谁就优先用谁，没有则往上找

​	2、间接通过成员方法访问成员变量

​		该方法属于谁就优先用谁，没有则往上找

##### 区分子类方法中重名的三种方式

​	局部变量					直接写成员变量名

​	本类的成员变量		 this.成员变量名

​	父类的成员变量		 super.成员变量名

##### 访问成员方法的规则

​	创建的对象是谁，就优先用谁，如果没有则向上查找

​	无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类

##### 父子类构造方法的访问特点

​	1、子类构造方法当中有一个默认隐含的"super()"调用，所有一定是先调用的父类构造，后执行的子类构造

​	2、子类构造可以通过super关键字调用父类重载构造

​	3、super的父类构造调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造

​	4、子类必须调用父类构造方法，不写则赠送super();写了则用指定的super调用，super只能有一个，还必须是	第一个

##### 重写（Override）

###### 概念

​	在继承关系当中，方法的名称一样，参数列表也一样

###### 方法覆盖重写的特点

​	创建的是子类对象，则优先用子类方法

方法覆盖重写的注意事项

​	1、必须保证父子类之间方法的名称相同，参数列表也相同

​		@Override：写在方法前面，用来检测是不是有效的正确的覆盖重写

​	2、子类方法的返回值必须小于等于父类方法的返回值范围

​		例如：父类方法的返回值是String类型，那么子类重写的方法的返回值是能是比String小的类，例如Object不	能写

​	3、子类方法的权限必须大于等于父类方法的权限修饰符

​		public > protected > (default) > private

##### super关键字的三种用法

1、在子类的成员方法中，访问父类的成员变量

2、在子类的成员方法中，访问父类的成员方法

3、在子类的构造方法中，访问父类的构造方法（写第一条语句）

##### this的三种用法

1、在本类的成员方法中，访问本类的成员变量

2、在本类的成员方法中，访问本类的另外一个成员方法

3、在本类的构造方法中，访问本类的另外一个构造方法（例如：无参访问有参的）

​	this()调用也必须是构造方法的第一个语句，唯一一个

​	super和this不能同时使用

##### this和super的内存分布

![img](C:\Users\48356\Desktop\笔记\image\QQ截图20200509173622.png)

##### Java继承的三个特点

Java语言是单继承的，一个类的直接父类只能有一个

#### 多态

一个对象拥有多种形态，这就是对象的多态性

代码当中体现多态性，其实就一句话：父类引用指向子类对象

格式：

​	父类名称 对象名 = new 子类名称();

​	或：

​	接口名称 对象名 = new 实现类名称();

```java
// 左侧父类的引用指向了右侧子类的对象
Fu obj = new Zi();
```

##### 访问成员变量的两种方式：

​	1、直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找

​	2、间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找

​		如果子类覆盖重写了父类的方法，那么就看子类方法的访问规则

​	成员变量：编译看左边，运行还看左边

​	成员方法：编译看左边，运行看右边

##### 使用多态的好处

![img](C:\Users\48356\Desktop\笔记\image\QQ截图20200512180143.png)

##### 对象向上转型

对象向上转型，其实就是多态写法：

格式：父类名称 对象名 = new 子类名称();

含义：右侧创建一个子类对象，把它当做父类来看待使用

注意事项：向上转型一定是安全的，从小范围转向了大范围

##### 对象向下转型

对象向下转型，其实就是一个还原的动作

格式：子类名称 对象名 = (子类名称) 父类对象;

含义：将父类对象，还原成为本来的子类对象

注意事项：

​	1、必须保证对象创建的时候，就是猫，才能向下转型成猫

​	2、如果对象创建的时候本来不是猫，现在非要向下转型成为猫，就会报错

##### instanceof关键字

​	instanceof判断一个父类引用的对象，本来是什么子类。

​	格式：对象 instanceof 类名称 					返回boolean类型的值

```java
判断animal是不是Dog类，如果是则向下转型成Dog类
if (animal instanceof Dog) {
	Dog dog = (Dog) animal;
}
```

### final关键字

final关键字代表最终、不可改变的

#### 常见四种用法

1、**可以用来修饰一个类**

​	格式：

​		public final class 类名称 {}

​		含义：当前这个类不能有任何子类

​		注意：final关键字修饰的类，可以覆盖重写父类的方法，没有子类

2、**可以用来修饰一个方法**

​	当final关键字用来修饰一个方法的时候，这个方法就是一个最终方法，也就是不能被覆盖重写

3、**还可以用来修饰一个局部变量**

​	对于基本类型来说，不可变说的是变量当中的数据不可改变

​	对于引用类型来说，不可变说的是变量当中的地址值不可改变

4、**还可以用来修饰一个成员变量**

​	对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变

​	1、由于成员变量有默认值，所以使用了final之后必须手动赋值，不会再给默认值了

​	2、对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值

​	3、必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值

对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾

### 抽象

#### 抽象方法

​	就是加上abstract关键字，然后去掉大括号，直接分号结束

#### 抽象类

​	抽象方法所在的类，必须是抽象类才行，在class之前加上abstract即可

#### 如何使用抽象类抽象方法

​	1、不能直接创建new抽象类

​	2、必须使用一个子类来继承抽象类

​	3、子类必须覆盖重写抽象父类的所有抽象方法

​	覆盖重写（实现）：去掉抽象方法的abstract关键字，然后补上方法体大括号

​	4、创建子类对象使用

注意事项

爷爷类

```java
public abstract class Animal {
	public abstract void eat();
    public abstract void sleep();
}
```

父亲类

```java
public abstract class Dog {
	@Override
	public void eat() {
		System.out.println("狗吃骨头");
	}
}
```

孙子类

```java
public class Dog2ha {
    public sleep() {
        System.out.println("嘿嘿嘿……");
    }
}
```

### 内部类

如果一个事物的内部包含另外一个事物，那么这就是一个类内部包含另外一个类

例如：身体跟心脏的关系

#### 分类

##### 1、成员内部类

​	定义格式：

```java
修饰符 class 外部类名称 {
	修饰符 class 内部类名称 {
        
    }	
}
内用外，随意访问，外用类，需要内部类对象
生成的.class文件名称是外部类名称$内部类名称.class
```

​	使用方法

​	1、间接方式：在外部类的方法当中，使用内部类，然后main只是调用外部类的方法

​	2、直接方式：公式：外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();

```java
System.out.println(num); 访问方法中的成员变量
System.out.println(this.num); 访问内部类中的成员变量
System.out.println(Body.this.num); 方法外部类中的成员变量
```

##### 2、局部内部类（包含匿名内部类）

如果一个类是定义在一个方法内部的，那么那么这就是一个局部内部类

定义格式：

```java
修饰符 class 外部类名称 {
    修饰符 返回值类型 方法名(参数列表) {
        class 局部内部类 {
            ……
        }
    }
}
```

#### 类的修饰符

1、外部类 public  / （default）

2、成员内部类 public  /  protected / (default) / private

3、局部内部类 什么都不能写

## 四种权限修饰符

|                      | public | protected | （default） | private |
| :------------------- | :----: | :-------: | :---------: | :-----: |
| 同一个类(我自己)     |   Y    |     Y     |      Y      |    Y    |
| 同一个包(我邻居)     |   Y    |     Y     |      Y      |    N    |
| 不同包子类(我儿子)   |   Y    |     Y     |      N      |    N    |
| 不同包非子类(陌生人) |   Y    |     N     |      N      |    N    |

## 接口

接口是一种**公共的规范标准**，只要符合规范就可以大家通用

接口就是多个类的公共规范，接口是一种引用数据类型，最重要的内容就是其中的：抽象方法

定义一个接口的格式

```java
public interface 接口名称 {
	// 接口内容
}
```

备注：换成关键字interface之后，编译生成的字节码文件仍然是：.java --> .class

### 接口中可以含有的内容

#### 1、常量

接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰，从效果上看这就是接口的常量

格式：

​	public static final 数据类型 常量名称 = 数据值;

一旦使用final关键字进行修饰，说明不可改变

注意事项：

​	1、接口当中的常量，可以省略public static final 

​	2、接口当中的常量，必须进行赋值，不能不赋值

​	3、接口中常量的名称，使用完全大写的字母，用下划线进行分割（推荐命名规则）

直接接口名点常量名调用

#### 2、抽象方法

​	格式：

​		public abstract 返回值类型 方法名称(参数列表);

​	注意事项：

​		1、接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract

​		2、这两个关键字可以选择性的省略，省略其中一个或全部都行

​		3、方法的三要素，可以随意定义

Java 8以上的版本

#### 3、默认方法	

​	格式：

```java
public default 返回值类型 方法名称(参数列表) { 
    方法体 
} 
```

备注：接口当中的默认方法，可以解决接口升级的问题

1、接口的默认方法，可以通过接口实现类对象，直接调用

2、接口的默认方法，也可以被接口实现类进行覆盖重写

#### 4、静态方法

​	格式：

```java
public static 返回值类型 方法名称(参数列表) {
	方法体
}
```

使用方法：直接使用接口名称调用静态方法

注意：不能通过接口实现类的对象来调用接口当中的静态方法

Java 9以上的版本

#### 5、私有方法	

1、普通私有方法，解决多个默认方法之间的重复代码问题

​	格式：

```java
private 返回值类型 方法名称(参数列表) {
    方法体
}
```

2、静态私有方法，解决多个多个静态方法之间重复代码问题

​	格式：

```
private static 返回值类型 方法名称(参数列表) {
	方法体
}
```

### 接口使用步骤

1、接口不能直接使用，必须要有一个**实现类**来**实现**该接口

格式：

```java
public class 实现类名称 implements 接口名称 {
	// ……
}
```

2、接口的实现类必须覆盖重写接口中的所有抽象方法

3、创建实现类的对象，进行使用

注意事项：

​	如果实现类没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类

### 使用接口的时候需要注意

1、接口是没有静态代码块或者构造方法的

2、一个类的直接父类是唯一的，但是一个类可以同时实现多个接口

​	格式：

```java
public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB {
    // 覆盖重写所有抽象方法
}
```

3、如果实现类实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可

4、如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类

5、如果实现类的所实现的多个接口中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写

6、一个类如果直接父类当中的方法和接口当中的默认方法产生了冲突，优先使用父类当中的方法

### 类和接口

1、类和类之间是单继承的，直接父类只有一个。

2、类和接口之间是多实现的，一个类可以实现多个接口

3、接口与接口之间是多继承的

```java 
public interface MyInterface extends MyInterfaceA, MyInterfaceB() {}
```

注意事项：

​	1、多个父接口当中的抽象方法如果重复，没关系

​	2、多个父接口当中的默认发如果重复，那么子接口必须进行默认方法的覆盖重写，**而且要带着default关键字**

## **常用API**  

概述：

API，应用程序编程接口

![img](.\image\a35b3649150c4bfbb936be935c9f7ed0.jpg)

### ArrayList类

数组的长度不可以发生改变，但是ArrayList集合的长度可以随意改变

对于ArrayList来说，有一个尖括号\<E\>表示泛型

泛型：也就是装在集合当中的所有元素，全都是统一的什么类型

注意：泛型只能是引用类型，不能是基本类型	

```java
ArrayList<String> list = new ArrayList<>(); 创建String类型的集合 
```

#### 注意事项：

对于ArrayList集合来说，直接打印得到的不是地址值，而是内容。

如果内容是空，得到的是空的中括号：[]

向集合中添加数据，需要用到add方法

#### ArrayList常用的方法

add(E e)添加  返回值是Boolean类型的，成功true 失败false

get(int index)获取 返回值是对应位置的元素

remove(int index)删除 删除对应位置的元素， 返回值是被删除的元素

size()获取集合的长度 返回集合的长度int类型

如果希望向集合ArrayList当中存储基本数据类型，必须使用基本类型对应的包装类

基本类型			包装类

byte				Byte

short			  Short

int 				  Integer

long				Long

float				Float

double		   Double

char				Character

boolean		  Boolean

ArrayList 做函数参数

```java
public static void printArrayList(ArrayList<Integer> arrayList) 
```

### **字符串String类**

#### 字符串的特点：

​	1、字符串的内容永不可变

​	2、正是因为字符串的不可变，所以字符串是可以共享

​	3、字符串效果上相当于char[]字符数组，但是底层原理是byte[]字节数组

#### 创建字符串常见3+1种方式

三种构造方法

​	public String():创建一个空白字符串，不含有任何内容

​	public String(char[] array):根据字符数组的内容来创建对应的字符串

​	public String(byte[] array):根据字节数组的内容来创建对应的字符串

一种直接创建

```
String str = "Hello, World"
```

#### 字符串常量池

字符串常量池：程序当中直接写上双引号字符串，就在字符串常量池中

![img](C:\Users\48356\Desktop\笔记\image\QQ截图20200505205818.png)

#### 字符串常用方法

​	改变字符的值，其实并没有改变其中的值，只是改变了它原有的地址

![img](C:\Users\48356\Desktop\笔记\image\改变内容String.png)

```java
equals(Object obj)：参数是任何对象，只有参数是一个字符串并且内容相同的才会给true，否则返回false
注意事项：
	1、任何对象都能用Object进行接收
	2、equals方法具有对称性，也就是a.equals(b)和b.equals(a)效果一样
	3、如果比较双方一个变量一个常量，推荐把常量字符串写在前面
	推荐："abc".equals(str)   不推荐：str.equals("abc")   当str为null的时候会报错
    
public boolean equalsIgnoreCase(String str);忽略大小写，进行内容的比较
    
public int length(); 获取字符串当中含有的字符个数，拿到字符串长度
    
public String concat(String str); 将当前字符串和参数字符串拼接成为返回值新的字符串  创建了新的字符串
    
public char charAt(int index); 获取指定索引位置的单个字符
    
public int indexOf(String str); 查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1
    
字符串截取：
public String substring(int index); 截取从参数位置一直到字符串结尾，返回新的字符串
    
public String substring(int begin, int end); 截取从begin开始，一直到end结束，中间的字符串，
[begin, end) 包含左边，不包含右边
 
public char[] toCharArray(); 将字符串转拆分成字符数组作为返回值
 
public byte[] getBytes(); 获得当前字符串底层字节数组
 
public String replace(charSequence oldString, charSequence newString); 
将所有出现的老字符串替换成新字符串，返回替换之后的结果新字符串, 
charSequence 一个接口，意思就是可以接收字符类型
 
public String[] split(String regex); 按照参数的规则，将字符串切分成若干个部分 regex是一个正则表达式
```

### Arrays类

```java
public static String toString(数组);将参数数组变成字符串
public static void sort(数组);按照默认升序（从小到大）对数组的元素进行排序
备注：
1、如果是数值，sort会默认按照升序从小到大
2、如果是字符串，sort默认按照字母升序
3、如果是自定义类型，那么这个自定义的类需要有Comparable或Comparator接口的支持
```

### Math类

```java
public static double abs(double num); 获取绝对值
public static double ceil(double num); 向上取整
public static double floor(double num); 向下取整
public static long round(double num); 四舍五入 有特殊情况 num是负数时且有两位小数是会比实际值小1
Math.PI(); 近似的圆周率常量
```

